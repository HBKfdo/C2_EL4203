# -*- coding: utf-8 -*-
"""EL4203_C2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KoBjmuw4MyDbJCv_KDN4dQse6UTOJ7k2
"""

'''CODIGO  WORD WRAP'''
def square(n):
    return n * n

def solveWordWrapUtil(words, n, length, wordIndex, remLength, memo):
    # Caso base para la última palabra
    if wordIndex == n - 1:
        memo[wordIndex][remLength] = 0 if (words[wordIndex] < remLength) else square(remLength)
        return memo[wordIndex][remLength]

    currWord = words[wordIndex]
    # Si la palabra cabe en la línea restante
    if currWord < remLength:
        memo[wordIndex][remLength] = min(
            solveWordWrapUsingMemo(
                words, n, length, wordIndex + 1,
                remLength - currWord if (remLength == length) else remLength - currWord - 1,
                memo
            ),
            square(remLength) + solveWordWrapUsingMemo(
                words, n, length, wordIndex + 1,
                length - currWord, memo
            )
        )
    else:
        # Si la palabra se coloca en la siguiente línea
        memo[wordIndex][remLength] = (square(remLength) + solveWordWrapUsingMemo(
            words, n, length, wordIndex + 1,
            length - currWord, memo
        ))

    return memo[wordIndex][remLength]

def solveWordWrapUsingMemo(words, n, length, wordIndex, remLength, memo):
    if memo[wordIndex][remLength] != -1:
        return memo[wordIndex][remLength]

    memo[wordIndex][remLength] = solveWordWrapUtil(words, n, length, wordIndex, remLength, memo)
    return memo[wordIndex][remLength]

def solveWordWrap(words, n, k):
    memo = [[-1] * (k + 1) for _ in range(n)]
    solveWordWrapUsingMemo(words, n, k, 0, k, memo)
    #print(memo)
    return memo

''''FIN CODIGO WORD WRAP'''



'''FUNCION AUXILIAR PARA CALCULAR LOS SALTOS DE LINEA'''
def skip_line(largos: list, maxWidth: int, memo: list) -> list:
    """
    Args:
        largos: list of word lengths
        maxWidth: max width of line
        memo: memoization matrix from solveWordWrap

    Returns: list of line breaks
    """
    n = len(largos)
    lines = []
    i = 0

    while i < n:
        line = []
        current_length = maxWidth

        while i < n:
          remLength = current_length - largos[i] - 1  # Longitud restante si agregamos la palabra y un espacio

          # Verificar si la palabra cabe en la línea actual y si corresponde al costo mínimo
          if remLength >= 0 and memo[i][remLength] == min(memo[i][remLength],  square(current_length) + memo[i][maxWidth - largos[i]]
          ):
              line.append(largos[i])
              current_length = remLength  # Actualizar la longitud restante
              i += 1
          else:
              break

        lines.append(line)

    return lines

'''FUNCION AUXILIAR PARA ABRIR UN ARCHIVO DE TEXTO'''
def read_text_file(file_path: str) -> str:
    """
    Args:
        file_path: path to text file

    Returns: text from file
    """
    return open(file_path, 'r').read()
'''FUNCION AUXILIAR PARA ACTUALIZAR UN ARCHIVO DE TEXTO'''
def update_text_file(filename: str, formatted_text: str) -> None:
    """
    Actualiza un archivo de texto existente con el texto formateado.

    Args:
    - filename (str): El nombre del archivo de texto a actualizar.
    - formatted_text (str): El texto formateado que se añadirá al archivo.

    Returns:
    - None
    """
    with open(filename, 'w') as file:
        file.write(formatted_text)

'''FUNCION PRINCIPAL'''
def format_text(text: str, maxWidth: int) -> list[str]:
    """
    Args:
        text: text to format
        maxWidth: max width of line

    Returns: list of lines
    """
    #Constrains
    if len(text) > 1000 or len(text) < 1:
        return "Error: text outside character limit"
    if maxWidth > 100 or maxWidth < 1:
        return "Error: maxWidth outside character limit"


    #Separacion de palabras
    list_text = text.split()
    len_words = [len(word) for word in list_text]
    n = len(len_words)

    #Calculo de saltos de linea optimos
    memo = solveWordWrap(len_words, n, maxWidth)
    line_breaks = skip_line(len_words, maxWidth, memo)


    #Distribuir equitativamente los espacios
    result = []
    index = 0
    for i, line in enumerate(line_breaks):
        if i == len(line_breaks) - 1:
            line_text = ' '.join(list_text[index:index + len(line)])
        else:
            line_text = list_text[index]
            line_length = len(line_text)
            for j in range(1, len(line)):
                line_text += ' ' + list_text[index + j]
                line_length += len(list_text[index + j]) + 1

            total_spaces = maxWidth - line_length
            spaces_needed = len(line) - 1
            if spaces_needed > 0:
                extra_spaces = total_spaces // spaces_needed
                remainder_spaces = total_spaces % spaces_needed

                line_text = list_text[index]
                for j in range(1, len(line)):
                    spaces = ' ' * (extra_spaces + 1)
                    if j <= remainder_spaces:
                        spaces += ' '
                    line_text += spaces + list_text[index + j]

        result.append(line_text)
        index += len(line)

    return result




def main():
    # Read text from file
    print('Insert path to the text file:')
    text_path = input()
    texto = read_text_file(text_path)

    print('Insert max width:')
    maxWidth = int(input())

    formatted_text = format_text(texto, maxWidth)
    if formatted_text== "Error: text outside character limit" or formatted_text== "Error: maxWidth outside character limit":
        print(formatted_text)
    else:
       # Update the existing text file with formatted text
       update_text_file(text_path, '\n'.join(formatted_text))
       print(f'Formatted text updated in "{text_path}".')

if __name__ == "__main__":
    main()

